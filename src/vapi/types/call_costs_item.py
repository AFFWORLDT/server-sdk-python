# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations
from ..core.pydantic_utilities import UniversalBaseModel
import typing
from ..core.pydantic_utilities import IS_PYDANTIC_V2
import pydantic
import typing_extensions
from ..core.serialization import FieldMetadata
from .analysis_cost_analysis_type import AnalysisCostAnalysisType


class CallCostsItem_Transport(UniversalBaseModel):
    type: typing.Literal["transport"] = "transport"
    minutes: float
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class CallCostsItem_Transcriber(UniversalBaseModel):
    type: typing.Literal["transcriber"] = "transcriber"
    transcriber: typing.Dict[str, typing.Optional[typing.Any]]
    minutes: float
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class CallCostsItem_Model(UniversalBaseModel):
    type: typing.Literal["model"] = "model"
    model: typing.Dict[str, typing.Optional[typing.Any]]
    prompt_tokens: typing_extensions.Annotated[float, FieldMetadata(alias="promptTokens")]
    completion_tokens: typing_extensions.Annotated[float, FieldMetadata(alias="completionTokens")]
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class CallCostsItem_Voice(UniversalBaseModel):
    type: typing.Literal["voice"] = "voice"
    voice: typing.Dict[str, typing.Optional[typing.Any]]
    characters: float
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class CallCostsItem_Vapi(UniversalBaseModel):
    type: typing.Literal["vapi"] = "vapi"
    minutes: float
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class CallCostsItem_Analysis(UniversalBaseModel):
    type: typing.Literal["analysis"] = "analysis"
    analysis_type: typing_extensions.Annotated[AnalysisCostAnalysisType, FieldMetadata(alias="analysisType")]
    model: typing.Dict[str, typing.Optional[typing.Any]]
    prompt_tokens: typing_extensions.Annotated[float, FieldMetadata(alias="promptTokens")]
    completion_tokens: typing_extensions.Annotated[float, FieldMetadata(alias="completionTokens")]
    cost: float

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


CallCostsItem = typing.Union[
    CallCostsItem_Transport,
    CallCostsItem_Transcriber,
    CallCostsItem_Model,
    CallCostsItem_Voice,
    CallCostsItem_Vapi,
    CallCostsItem_Analysis,
]
